"  VUNDLE.VIM STUFF  {{{1"


set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
Plugin 'easymotion/vim-easymotion'
Plugin 'takac/vim-hardtime'
Plugin 'burnettk/vim-angular'
Plugin 'majutsushi/tagbar'
Plugin 'godlygeek/tabular'
Plugin 'tpope/vim-fugitive'
Plugin 'vim-scripts/gnuplot.vim'
Plugin 'alejandrogallo/vasp.vim'
Plugin 'alejandrogallo/vim-asymptote'
Plugin 'flazz/vim-colorschemes'
Plugin 'scrooloose/syntastic'
Plugin 'tpope/vim-surround'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'dhruvasagar/vim-table-mode'
if has("lua")
  " it needs lua!
  Plugin 'Shougo/neocomplete.vim'
endif
Plugin 'ervandew/supertab'
Plugin 'jlanzarotta/bufexplorer'
Plugin 'scrooloose/nerdcommenter'
if v:version >= 704
  "it needs vim 7.04..
  Plugin 'SirVer/ultisnips'
endif
Plugin 'honza/vim-snippets'
Plugin 'mattn/emmet-vim'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'bling/vim-airline'
Plugin 'scrooloose/nerdtree'
" Track the engine.
Plugin 'VundleVim/Vundle.vim'
" All of your Plugins must be added before the following line
call vundle#end()




" GENERAL STUFF {{{1 "

function! TrailingSpacesClean()
  echom "Removing trailing spaces"
  %s/\v\s+$//g
endfunction
" convert print as a keyword in python 2 to a function for python 3
fun! PrintPython2ToPython3()
  %s/\vprint\s+(.*)/print(\1)/c
endf

"set undo stuff, it needs VIM 7.3 at least
if has("persistent_undo")
" src: http://stackoverflow.com/questions/17936130/vim-undo-undo-changes-after-file-write
  set undofile
  set undodir=$MYVIMRC/etc/undo
endif

" allowing modeline
set modeline

"No compatibility with vi
set nocompatible

"Go to normal mode typing  kj in insert mode
inoremap kj <ESC>

" map : to -
noremap - :

"Autocompletion from vim
set omnifunc=syntaxcomplete#Complete

"Numbering of lines
set number

" Relative numbering
if v:version >= 704
  "is only supported for vim 7.04 and above...
  set relativenumber
endif

filetype plugin on

"Automatic indentation for plugins
filetype plugin indent on

"enable coloring and so on
syntax enable

"Highlight search as you type the searching word
set incsearch

"provide a graphical menu of all the matches you can cycle through in the command line
set wildmenu

" Marks for special characters
set listchars=eol:¬,trail:·
set listchars+=tab:>\ 
" Activate listchars
set list


" Grep stuff {{{1 "

function! GrepAndReplace(word, ...)
  let folder = "."
  let word_replace = ""
  echom "Contents of the replacing list"
  echom "------------------------------"
  let i = 1
  for argument in a:000
    echom i
    if i == len(a:000)
      let word_replace = word_replace.argument
    else
      let word_replace = word_replace.argument." "
    endif
    let i+=1
    echom argument
  endfor
  let command = "grep -E \"".a:word."\" -R ".folder
  echom "Replacing... : ".a:word
  echom "By           : ".word_replace
  echom command
  call setqflist([])
  execute command
  let qflist = getqflist()
  for matchfl in qflist
    execute ".s/".a:word."/".word_replace."/gc"
    execute "write"
    execute "cnext"
    "try
      "execute "cnext"
    "catch
      "echom "No more items"
    "endtry
  endfor
endfunction

command! -nargs=* Greplace call GrepAndReplace(<f-args>)


" Leader and localleader {{{1 "

"Set maplocalleader to something else if you like
let maplocalleader = "\<Space>"

"Set maplocalleader to something else if you like
let mapleader = ','

"Save current buffer
nnoremap <localleader>w :w<cr>

"Close vim without saving
nnoremap <localleader>q :q<cr>

"/ is way too far away, and I want case insensitive!
nnoremap <localleader>f /\c

" too complicated to replace
nnoremap <localleader>r :%s/
"replace in the current visual selection
vnoremap <localleader>r :s/
" replace at the current line
nnoremap <localleader>rr :.s/

"Toggle NERDTree file structure easily
noremap <localleader>ne :NERDTreeToggle<cr>

" Toggle Tagbar
noremap <localleader>tg :TagbarToggle<cr>

"edit vimrc
nnoremap <localleader>V :e $HOME/.vim/etc/vimrc<cr>

" edit bashrc
nnoremap <localleader>B :edit $DOTFILES/link/bashrc<cr>

" align stuff for =
vnoremap <localleader>t :Tabularize /


" paste adding a blank space
nnoremap <localleader>p :normal! a <ESC>p



" Folding stuff {{{1 "
nnoremap <localleader>zmm :set foldmethod=marker<cr>
nnoremap <localleader>zmi :set foldmethod=indent<cr>

" Quickfix stff {{{1 "

" remap ccnext and cprevious, nice for grep, make etc...
nnoremap <localleader>cn :cnext<cr>
nnoremap <localleader>cp :cprevious<cr>

" Buffer control {{{1 "

"Change to next buffer
noremap <Tab> :bn<CR>

"Change to previous buffer
noremap <S-Tab> :bp<CR>

"Delete
nnoremap <localleader>bd :bd<CR>

" buffer explorer
"nnoremap <localleader>bb :normal <leader>be<cr>




"  AIRLINE  {{{1"


let g:airline_powerline_fonts = 0

let g:Powerline_symbols = 'fancy'

let g:airline_theme = 'badwolf'

let g:airline#extensions#tabline#enabled = 1

" To get the downbar
set laststatus=2


"  ULTISNIPS STUFF  {{{1"
let g:UltiSnipsExpandTrigger="<C-j>"

let g:UltiSnipsJumpForwardTrigger="<C-j>"

let g:UltiSnipsJumpBackwardTrigger="<c-k>"

let g:UltiSnipsListSnippets="<c-l>"

let g:UltiSnipsEditSplit="vertical"




"  TAB CONFIGURATION  {{{1"


"Set tabstop to tell vim how many columns a tab counts for
set tabstop=2

"When expandtab is set, hitting Tab in insert mode will produce the appropriate number of spaces.
set expandtab

"Set shiftwidth to control how many columns text is indented with the reindent operations (<< and >>)
set shiftwidth=2

"Set softtabstop to control how many columns vim uses when you hit Tab in insert mode
set softtabstop=2

"Set tab to 4
nmap \t :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>

"Set tab to 8 with insertmode tab to 4
nmap \T :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>

"Some other common configuration
nmap \M :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>

"Set tab to 2
nmap \m :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>

" Text Formatting {{{1 "
function! CreateRsTTitle(character)
  "This function creates a header of the rst type
  "We use execute because then we can write Esc inside the command
  execute "normal! yypv^$r".a:character."\<ESC>"
endfunction
nnoremap <localleader>t= :call CreateRsTTitle("=")<cr>
nnoremap <localleader>t- :call CreateRsTTitle("-")<cr>
nnoremap <localleader>t~ :call CreateRsTTitle("~")<cr>



"  EMMET.VIM  {{{1"
"Remap emmet trigger jey ctrl + e (CTRL+EMMET)
let g:user_emmet_leader_key='<C-e>'



"  NEOCOMPLETE.VIM  {{{1"

" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_fuzzy_completion = 1




"  TERM STUFF  {{{1"

if &term ==# "xterm"
  " Sometimes when environment variable TERM is only set
  " to xterm, I have problems with colors, so I try to
  " force 256 colors and not only 8
  let &term = "xterm-256color"
elseif &term ==# "screen"
  let &t_Co = 256
endif


"  Ctrl-p  {{{1"

let g:ctrlp_map = 'Q' " This is the default
let g:ctrlp_cmd = 'CtrlP'
nnoremap <localleader>bb :CtrlPBuffer<cr>

" Ignore files in .gitignore
let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']





"  MOVING AROUNDK  {{{1"

"go to the next parentheses
nnoremap gp /(<CR>
nnoremap gP ?(<CR>


"  SYNTASTIC  {{{1"

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
" ignore some anoying warnings


"  colortheme  {{{1"

let g:solarized_termcolors=256
colorscheme solarized
let b:hour = strftime("%H")
if b:hour >= 9 && b:hour <=15
  set background=light
else
  set background=dark
endif
set background=dark


" vim:foldmethod=marker

